// @file	iocp.cpp
//
//

#include "iocp.h"


namespace lib
{
	////////////////////////////////////////////////////////////////////////////////
	//
	////////////////////////////////////////////////////////////////////////////////
	Iocp::Iocp() : _handle(INVALID_HANDLE_VALUE), _last_error(0)
	{

	}

	////////////////////////////////////////////////////////////////////////////////
	//
	////////////////////////////////////////////////////////////////////////////////
	Iocp::~Iocp()
	{

	}

	////////////////////////////////////////////////////////////////////////////////
	//
	////////////////////////////////////////////////////////////////////////////////
	INT32	Iocp::initialize()
	{
		_handle = CreateIoCompletionPort(INVALID_HANDLE_VALUE, nullptr, 0, 0);
		if (INVALID_HANDLE_VALUE == _handle)
		{
			record_error();
			return ERR_IOCP_CREATE;
		}

		return ERR_SUCCEEDED;
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	////////////////////////////////////////////////////////////////////////////////
	VOID	Iocp::close()
	{
		CloseHandle(_handle);
		_handle = INVALID_HANDLE_VALUE;
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	////////////////////////////////////////////////////////////////////////////////
	BOOL Iocp::associate(INT32 key_in, const SOCKET& socket_in)
	{
		HANDLE result = CreateIoCompletionPort((HANDLE)socket_in, _handle, key_in, 0);
		if (INVALID_HANDLE_VALUE == result)
		{
			record_error();
			return FALSE;
		}
		return TRUE;
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	////////////////////////////////////////////////////////////////////////////////
	INT32 Iocp::pop_income(INT32& key_out, UINT32& bytes_out, LPOVERLAPPED* overlapped_out)
	{
		if (FALSE == GetQueuedCompletionStatus(_handle, (LPDWORD)&bytes_out, (PULONG_PTR)&key_out, overlapped_out, INFINITE))
		{
			record_error();
			return ERR_IOCP_QUEUE;
		}

		if (0 == bytes_out && nullptr == overlapped_out)
			return ERR_IOCP_QUEUE;

		return ERR_SUCCEEDED;
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	////////////////////////////////////////////////////////////////////////////////
	INT32 Iocp::push_forcely(INT32 key_in, OVERLAPPED * overlapped_in)
	{
		if (FALSE == PostQueuedCompletionStatus(_handle, 1, key_in, overlapped_in))
		{
			record_error();
			return ERR_IOCP_POST;
		}

		return ERR_SUCCEEDED;
	}

	////////////////////////////////////////////////////////////////////////////////
	//
	////////////////////////////////////////////////////////////////////////////////
	INT32	Iocp::record_error()
	{
		return _last_error = WSAGetLastError();
	}
}